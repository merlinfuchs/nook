// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: subscription.sql

package pgmodel

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getSubscriptionByID = `-- name: GetSubscriptionByID :one
SELECT id, user_id, status, paddle_subscription_id, paddle_customer_id, paddle_product_ids, paddle_price_ids, created_at, started_at, paused_at, canceled_at, current_period_ends_at, current_period_starts_at, updated_at FROM subscriptions WHERE id = $1
`

func (q *Queries) GetSubscriptionByID(ctx context.Context, id int64) (Subscription, error) {
	row := q.db.QueryRow(ctx, getSubscriptionByID, id)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Status,
		&i.PaddleSubscriptionID,
		&i.PaddleCustomerID,
		&i.PaddleProductIds,
		&i.PaddlePriceIds,
		&i.CreatedAt,
		&i.StartedAt,
		&i.PausedAt,
		&i.CanceledAt,
		&i.CurrentPeriodEndsAt,
		&i.CurrentPeriodStartsAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSubscriptionsByGuildID = `-- name: GetSubscriptionsByGuildID :many
SELECT subscriptions.id, subscriptions.user_id, subscriptions.status, subscriptions.paddle_subscription_id, subscriptions.paddle_customer_id, subscriptions.paddle_product_ids, subscriptions.paddle_price_ids, subscriptions.created_at, subscriptions.started_at, subscriptions.paused_at, subscriptions.canceled_at, subscriptions.current_period_ends_at, subscriptions.current_period_starts_at, subscriptions.updated_at FROM subscriptions 
LEFT JOIN entitlements ON subscriptions.id = entitlements.subscription_id 
WHERE entitlements.guild_id = $1
ORDER BY subscriptions.created_at DESC
`

func (q *Queries) GetSubscriptionsByGuildID(ctx context.Context, guildID int64) ([]Subscription, error) {
	rows, err := q.db.Query(ctx, getSubscriptionsByGuildID, guildID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Subscription
	for rows.Next() {
		var i Subscription
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Status,
			&i.PaddleSubscriptionID,
			&i.PaddleCustomerID,
			&i.PaddleProductIds,
			&i.PaddlePriceIds,
			&i.CreatedAt,
			&i.StartedAt,
			&i.PausedAt,
			&i.CanceledAt,
			&i.CurrentPeriodEndsAt,
			&i.CurrentPeriodStartsAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubscriptionsByUserID = `-- name: GetSubscriptionsByUserID :many
SELECT id, user_id, status, paddle_subscription_id, paddle_customer_id, paddle_product_ids, paddle_price_ids, created_at, started_at, paused_at, canceled_at, current_period_ends_at, current_period_starts_at, updated_at FROM subscriptions WHERE user_id = $1 ORDER BY created_at DESC
`

func (q *Queries) GetSubscriptionsByUserID(ctx context.Context, userID int64) ([]Subscription, error) {
	rows, err := q.db.Query(ctx, getSubscriptionsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Subscription
	for rows.Next() {
		var i Subscription
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Status,
			&i.PaddleSubscriptionID,
			&i.PaddleCustomerID,
			&i.PaddleProductIds,
			&i.PaddlePriceIds,
			&i.CreatedAt,
			&i.StartedAt,
			&i.PausedAt,
			&i.CanceledAt,
			&i.CurrentPeriodEndsAt,
			&i.CurrentPeriodStartsAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertSubscription = `-- name: UpsertSubscription :one
INSERT INTO subscriptions (
    id,
    user_id,
    status,
    paddle_subscription_id,
    paddle_customer_id,
    paddle_product_ids,
    paddle_price_ids,
    created_at,
    started_at,
    paused_at,
    canceled_at,
    current_period_ends_at,
    current_period_starts_at,
    updated_at
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10,
    $11,
    $12,
    $13,
    $14
) ON CONFLICT (paddle_subscription_id) DO UPDATE SET
    status = EXCLUDED.status,
    paddle_customer_id = EXCLUDED.paddle_customer_id,
    paddle_product_ids = EXCLUDED.paddle_product_ids,
    paddle_price_ids = EXCLUDED.paddle_price_ids,
    started_at = EXCLUDED.started_at,
    paused_at = EXCLUDED.paused_at,
    canceled_at = EXCLUDED.canceled_at,
    current_period_ends_at = EXCLUDED.current_period_ends_at,
    current_period_starts_at = EXCLUDED.current_period_starts_at,
    updated_at = EXCLUDED.updated_at
RETURNING id, user_id, status, paddle_subscription_id, paddle_customer_id, paddle_product_ids, paddle_price_ids, created_at, started_at, paused_at, canceled_at, current_period_ends_at, current_period_starts_at, updated_at
`

type UpsertSubscriptionParams struct {
	ID                    int64
	UserID                int64
	Status                string
	PaddleSubscriptionID  string
	PaddleCustomerID      string
	PaddleProductIds      []string
	PaddlePriceIds        []string
	CreatedAt             pgtype.Timestamp
	StartedAt             pgtype.Timestamp
	PausedAt              pgtype.Timestamp
	CanceledAt            pgtype.Timestamp
	CurrentPeriodEndsAt   pgtype.Timestamp
	CurrentPeriodStartsAt pgtype.Timestamp
	UpdatedAt             pgtype.Timestamp
}

func (q *Queries) UpsertSubscription(ctx context.Context, arg UpsertSubscriptionParams) (Subscription, error) {
	row := q.db.QueryRow(ctx, upsertSubscription,
		arg.ID,
		arg.UserID,
		arg.Status,
		arg.PaddleSubscriptionID,
		arg.PaddleCustomerID,
		arg.PaddleProductIds,
		arg.PaddlePriceIds,
		arg.CreatedAt,
		arg.StartedAt,
		arg.PausedAt,
		arg.CanceledAt,
		arg.CurrentPeriodEndsAt,
		arg.CurrentPeriodStartsAt,
		arg.UpdatedAt,
	)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Status,
		&i.PaddleSubscriptionID,
		&i.PaddleCustomerID,
		&i.PaddleProductIds,
		&i.PaddlePriceIds,
		&i.CreatedAt,
		&i.StartedAt,
		&i.PausedAt,
		&i.CanceledAt,
		&i.CurrentPeriodEndsAt,
		&i.CurrentPeriodStartsAt,
		&i.UpdatedAt,
	)
	return i, err
}
