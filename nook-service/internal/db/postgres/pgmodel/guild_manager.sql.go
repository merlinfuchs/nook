// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: guild_manager.sql

package pgmodel

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteGuildManager = `-- name: DeleteGuildManager :exec
DELETE FROM guild_managers WHERE guild_id = $1 AND user_id = $2
`

type DeleteGuildManagerParams struct {
	GuildID int64
	UserID  int64
}

func (q *Queries) DeleteGuildManager(ctx context.Context, arg DeleteGuildManagerParams) error {
	_, err := q.db.Exec(ctx, deleteGuildManager, arg.GuildID, arg.UserID)
	return err
}

const getGuildManager = `-- name: GetGuildManager :one
SELECT guild_id, user_id, role, created_at, updated_at FROM guild_managers WHERE guild_id = $1 AND user_id = $2
`

type GetGuildManagerParams struct {
	GuildID int64
	UserID  int64
}

func (q *Queries) GetGuildManager(ctx context.Context, arg GetGuildManagerParams) (GuildManager, error) {
	row := q.db.QueryRow(ctx, getGuildManager, arg.GuildID, arg.UserID)
	var i GuildManager
	err := row.Scan(
		&i.GuildID,
		&i.UserID,
		&i.Role,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getGuildManagers = `-- name: GetGuildManagers :many
SELECT guild_id, user_id, role, created_at, updated_at FROM guild_managers WHERE guild_id = $1
`

func (q *Queries) GetGuildManagers(ctx context.Context, guildID int64) ([]GuildManager, error) {
	rows, err := q.db.Query(ctx, getGuildManagers, guildID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GuildManager
	for rows.Next() {
		var i GuildManager
		if err := rows.Scan(
			&i.GuildID,
			&i.UserID,
			&i.Role,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGuildManagersWithUsers = `-- name: GetGuildManagersWithUsers :many
SELECT guild_managers.guild_id, guild_managers.user_id, guild_managers.role, guild_managers.created_at, guild_managers.updated_at, users.id, users.username, users.discriminator, users.display_name, users.avatar, users.created_at, users.updated_at 
FROM guild_managers JOIN users ON guild_managers.user_id = users.id 
WHERE guild_managers.guild_id = $1
`

type GetGuildManagersWithUsersRow struct {
	GuildManager GuildManager
	User         User
}

func (q *Queries) GetGuildManagersWithUsers(ctx context.Context, guildID int64) ([]GetGuildManagersWithUsersRow, error) {
	rows, err := q.db.Query(ctx, getGuildManagersWithUsers, guildID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGuildManagersWithUsersRow
	for rows.Next() {
		var i GetGuildManagersWithUsersRow
		if err := rows.Scan(
			&i.GuildManager.GuildID,
			&i.GuildManager.UserID,
			&i.GuildManager.Role,
			&i.GuildManager.CreatedAt,
			&i.GuildManager.UpdatedAt,
			&i.User.ID,
			&i.User.Username,
			&i.User.Discriminator,
			&i.User.DisplayName,
			&i.User.Avatar,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertGuildManager = `-- name: UpsertGuildManager :one
INSERT INTO guild_managers (
    guild_id,
    user_id,
    role,
    created_at,
    updated_at
) VALUES ($1, $2, $3, $4, $5)
ON CONFLICT (guild_id, user_id) DO UPDATE SET
    role = EXCLUDED.role,
    updated_at = EXCLUDED.updated_at
RETURNING guild_id, user_id, role, created_at, updated_at
`

type UpsertGuildManagerParams struct {
	GuildID   int64
	UserID    int64
	Role      string
	CreatedAt pgtype.Timestamp
	UpdatedAt pgtype.Timestamp
}

func (q *Queries) UpsertGuildManager(ctx context.Context, arg UpsertGuildManagerParams) (GuildManager, error) {
	row := q.db.QueryRow(ctx, upsertGuildManager,
		arg.GuildID,
		arg.UserID,
		arg.Role,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i GuildManager
	err := row.Scan(
		&i.GuildID,
		&i.UserID,
		&i.Role,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
